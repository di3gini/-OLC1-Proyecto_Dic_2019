package analizadores;

import java_cup.runtime.*;
import arbol.AST;
import arbol.Expresion;
import arbol.Instruccion;
import arbol.entorno.*;
import arbol.entorno.Tipo.EnumTipo;
import arbol.expresiones.Id;
import arbol.expresiones.Literal;
import arbol.instrucciones.Asignacion;
import arbol.instrucciones.Declaracion;
import arbol.instrucciones.Imprimir;
import arbol.aritmetica.*;
import arbol.instrucciones.Incre;
import arbol.instrucciones.Decre;
import arbol.Logicas.*;
import arbol.Comparativas.*;
import java.util.LinkedList;



parser code 
{:   

    /* Variable que guarda el árbol de sintáxis abstracta generado luego del análisis sintáctico */
    public AST AST;
    
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+".");

            //Interfaz.lista_errores.add(new CError("Sintáctico", "No se esperaba este componente '" + s.value + "'", s.left, s.right));
    
    } 
    /**
     * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
    }  
:} 

terminal String mas,menos,por,division,parizquierdo,parderecho,igual,puntoycoma,llaveizq,llaveder,rint,rdouble,rchar,rboolean,rstring,rclass,coma,rvoid;
terminal String entero,doble,rtrue,rfalse,cadena,caracter,id,rprintln,rprint,rprinttabla;
terminal String menorque,mayorque,menorigualque,mayorigualque,igualigual,diferenteque,ror,rand,rxor,rnot,rif,relse,rwhile,rbreak,rcontinue,modulo,rfor,rdo,rswitch,rcase,rdefault,dospuntos,interrogacion,masmas,menosmenos,rpow,rreturn,corizquierdo,corderecho,rnew,rpublic,rprotected,rprivate,rabstract,rstatic,rfinal,rstr,rtoDouble,rtoInt,rtoChar,rextends,punto,rthis,rnull,rimport,
rgraph,rsuper,rread_file,rwrite_file,rinstanceof,rread;

terminal umenos; //Para manejar el - E

non terminal INICIO;
non terminal LinkedList<Instruccion> L_INSTRUCCIONES;
non terminal Instruccion INSTRUCCION,DECLARACION,ASIGNACION, IMPRIMIR, INCREMENTO, DECREMENTO;
non terminal Expresion E;
non terminal Expresion OP_COMPA;
non terminal Tipo T;


//Operaciones numericas
//precedence left interrogacion; //Así lo tenía antes
precedence right interrogacion,dospuntos;


precedence left ror;
precedence left rand;
precedence left rxor;
precedence right rnot;

precedence left menorque,menorigualque,mayorque,mayorigualque,igualigual,diferenteque;

precedence left mas,menos;
precedence left por,division,modulo;
precedence left rpow;
//precedence left masmas,menosmenos; //Así lo tenía antes

precedence left punto; //Para los accesos

precedence left umenos;

start with INICIO; 

INICIO::= L_INSTRUCCIONES:a
    {:
    //se guarda el AST, que es la lista principal de instrucciones en la variable
    //AST que se definió dentro del parser
    parser.AST = new AST(a);
        
    :}
;


L_INSTRUCCIONES ::= L_INSTRUCCIONES:a INSTRUCCION:b {: RESULT=a; RESULT.add(b); :}
                            | INSTRUCCION:a {: RESULT=new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= DECLARACION:a puntoycoma {: RESULT = a; :}
            | ASIGNACION:a puntoycoma {: RESULT = a; :}
            | IMPRIMIR:a puntoycoma{: RESULT = a; :}
            | INCREMENTO:a puntoycoma{: RESULT = a; :}
            | DECREMENTO:a puntoycoma{: RESULT = a; :}
            
            
            

;



DECLARACION ::= 
        T:a id:b igual E:c {: RESULT = new Declaracion(a,b,c,bleft, bright); :}
        | T:a id:b {: RESULT=new Declaracion(a,b,bleft, bright); :}
        
        
;

ASIGNACION ::= 
                id:a igual E:b {: RESULT = new Asignacion(a,aleft,aright,b); :}
                //| id:a L_DIMENSIONES_EXPRESION:b igual E:c {: RESULT = new AsignacionArreglo(a,aleft,aright,b,c); :}
                
;

T ::= rint:a {: RESULT = new Tipo(Tipo.EnumTipo.entero); :}
    | rchar {: RESULT = new Tipo(Tipo.EnumTipo.caracter); :}
    | rboolean {: RESULT = new Tipo(Tipo.EnumTipo.booleano); :}
    | rdouble {: RESULT = new Tipo(Tipo.EnumTipo.doble); :}
    | rstring {: RESULT = new Tipo(Tipo.EnumTipo.cadena); :}
;

IMPRIMIR ::= rprintln parizquierdo E:a parderecho {: RESULT=new Imprimir(a, true); :}
    | rprint parizquierdo E:a parderecho {: RESULT=new Imprimir(a, false); :}

;

INCREMENTO ::= id:a masmas {: RESULT=new Incre(a,aright,aleft);:}
;

DECREMENTO ::= id:a menosmenos {: RESULT = new Decre(a,aright,aleft);:}
;







E ::= 
        entero:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.entero), a); :}
        | caracter:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.caracter), a.replace("\'","")); :}
        //| caracter:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.caracter), a); :}
        | rtrue {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.booleano), true); :}
        | rfalse {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.booleano), false); :}
        | doble:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.doble), a); :}
        | cadena:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.cadena), a.replace("\"","")); :}
        //| cadena:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.cadena), a); :}
        | rnull {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.nulo)); :}

        | id:a {: RESULT = new Id(a, aleft,aright); :}
        
        | E:a mas E:b{:RESULT = new suma(aleft,aright, a, b); :}
        | E:a menos E:b {: RESULT = new resta(aleft,aright,a,b);:}
        | E:a por E:b {: RESULT = new multiplicacion(aleft, aright, a, b);:}
        | E:a division E:b {: RESULT = new division(aleft, aright, a, b);:}
        | E:a rpow E:b {: RESULT = new potencia(aleft, aright, a, b);:}
        | E:a modulo E:b {: RESULT = new modulo(aleft, aright, a, b);:}

        | id:a masmas {: RESULT= new incremento(aleft, aright, a);:}
        | id:a menosmenos {: RESULT = new decremento(aleft, aright, a); :}
        
        |E:a mayorque E:b {: RESULT = new Mayor(aleft, aright, a, b);:}
        | E:a menorque E:b {: RESULT = new Menor(aleft, aright, a, b);:}
        | E:a mayorigualque E:b {: RESULT = new MayorIgual(aleft, aright, a, b);:}
        | E:a menorigualque E:b {: RESULT = new MenorIgual(aleft, aright, a, b);:}
        | E:a igualigual E:b {: RESULT = new Igual(aleft, aright, a, b);:}
        | E:a diferenteque E:b {: RESULT = new Diferente(aleft, aright, a, b);:}


        | E:a ror E:b {:RESULT = new OpOr(aleft, aright, a, b);:}
        | E:a rand E:b {:RESULT = new OpOr(aleft, aright, a, b);:}
        | E:a rxor E:b {:RESULT = new OpOr(aleft, aright, a, b);:}
        //| not E:a { :RESULT = new OpOr(aleft, aright, a)}
       
        
        

;


